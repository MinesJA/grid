from uuid import uuid1, UUID
from grid.envelopes import Envelope, Tell, Ask, Response
from grid.messages import Message
from grid.models.nodeProxy import NodeProxy
from grid.models.actor import Actor
from typing import Type, Sequence, Dict


class MessageRegisteredException(Exception):
    """Indicates that a Tell or Ask Envelope has already
    been registered by this Node.
    """

    def __init__(self, env, message="Message already registered"):
        self.env = env
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return f'{self.env} -> {self.message}'


class Package:

    def __init__(self, org_env: Type[Envelope] = None):
        """Package represents a group of requests sent by
        a Node to it's siblings. These can be Tells, Asks, or Responses.

        Package's can serve two purposes:
            1. To keep track of which nodes have already been
            contacted to prevent endless loops.

            2. To retrace the path back to the originating
            node in the case of an Ask - Response cycle. When all Ask
            messages have been responded to the Package can be reduced
            to a single Response message and sent back to the return_to Node.

        Args:
            org_env (Type[Envelope], optional): Received envelope that
                triggered the package. Optional because the genesis package
                is not responding to a received envelope.
        """
        self.org_env = org_env
        self.requests = {}
        self.responses = {}

    def register(self, env: Envelope) -> None:
        if env.reqid in self.requests:
            # TODO: Is this even possible?
            raise RuntimeError(f'{env.reqid} already registered to package.')

        if isinstance(env, Response):
            self.responses.update({env.reqid: env})
        else:
            self.requests.update({env.reqid: env})

    def gen_msg(self, sender, resp):
        """Packages up responses according to reduce of original
        request.

        Args:
            sender ([type]): [description]

        Raises:
            ValueError: [description]

        Returns:
            [type]: [description]
        """
        if not self.is_ready():
            raise RuntimeError('{self.org_env} Package is not ready to ship')

        return resp.msg.reduce(self.responses, sender)

    def get_req(self, reqid: UUID) -> Type[Envelope]:
        self.requests.get(reqid)

    def req_completed(self) -> bool:
        """All initial Asks have received Responses
        and this Package is the genesis package.

        Returns:
            bool: [description]
        """
        return self.is_ready and self.org_env is None

    def is_ready(self) -> bool:
        """Package has had all requests addressed
        and completed.

        TODO: Confirm this is safe. Seems potentially
            problematic.

        Returns:
            boolean: True if Package is Completed
        """
        return len(self.requests) == len(self.responses)


class MailRoom:

    def __init__(self):
        """Keeps track of what messages are awaiting responses
        in either direction. If a message is sent by a node and needs
        a reply and if a Node needs to respond to a message it was
        sent.

        {master_reqid: Package}
        Package
            - {reqid: Tell or Ask}
            - {respid: Response}

        Args:
            return_id ([type]): [description]
        """
        self._packages = {}

    # def build_genesis(self, env):
    #     package = Package({env.reqid: env}, env)
    #     self._packages.update({env.master_reqid: package})

    def register_inbound(self, env: Envelope):
        """Inbound messages are either the genesis of
        a new Package (and will propagate more messages)
        OR they are the Response from a previous Ask.

        Responses should always have a corresponding
        Package (because their genesis was initially an
        Ask which should have registered a Package).

        If an Ask or Tell already has a Package registered
        it's because another message generated by the same Node
        earlier in the chain beat this msg to this Node.
        Need to handle this situation.

        Args:
            env (Envelope): Incoming Envelope to be registered

        Raises:
            RuntimeError: [description]
        """
        if isinstance(env, Response):
            package = self._get_package(env.master_reqid)
            if package is None:
                raise RuntimeError(f'No package for {env}')
            package.register(env)
        else:
            if env.master_reqid in self._packages:
                raise MessageRegisteredException(env)
            package = Package(env)
            self._packages.update({env.master_reqid: package})

    def register_outbound(self, env: Envelope):
        package = self._get_package(env.master_reqid)
        package.register(env)

    def registered(self, env: Envelope) -> bool:
        return self._get_package(env.master_reqid) is not None

    def should_forward(self,
                       env: Envelope,
                       recipients: Sequence[Actor]) -> bool:
        # already_processed = self.mailroom.is_registered(ask)
        # should_forward = not already_processed and len(siblings) > 0
        # dead_end = len(siblings) < 1

        if isinstance(env, Response):
            package = self._get_package(env.master_reqid)
            return package.is_ready()
        else:
            already_forwarded = self.mailroom.is_registered(env)
            dead_end = len(recipients) < 1
            return not already_forwarded and not dead_end

    # def req_completed(self, env):
    #     if package.is_ready():
    #         msg = package.gen_msg(sender, resp)
    #         if package.req_completed():

    def build_return_msg(self, env: Envelope, sender: Actor) -> Message:
        """Used to generate a response message.

        If envelope is an Ask, 

        If Ask has already been registered, it means another
        Ask generated from same master_reqid got to the Node
        first. Return empty data.

        If the message reaches a dead end, return that Node's
        data.

        If the message has reached a dead end, return
        or if it hits
        an adjacent node that's already processed the forwarded
        message

        Args:
            env (Envelope): [description]
            sender (Actor): [description]

        Returns:
            Message: [description]
        """
        if self.registered(env):
            # If Ask is already registered, return empty data
            return env.msg.reduce({})
        elif isinstance(env, Response):

        else:
            # Return senders data
            return env.msg.reduce({}, sender)



    def close_package(self, env: Type[Envelope]):
        self._packages.pop(env.master_reqid)

    def _get_req(self, resp) -> Ask:
        # TODO: Not safe..._get_package can return None
        return self._get_package(resp.master_reqid).get_req(resp.reqid)

    def _get_package(self, master_reqid) -> Package:
        # TODO: Should this be a getter of some kind?
        return self._packages.get(master_reqid)
